# -*- coding: utf-8 -*-
"""Untitled14.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1drLGH_DaAQzN535WNaHHv1mzT0MfqjB8
"""

import numpy as np
import math
import matplotlib.pyplot as plt
from scipy.stats import norm, gaussian_kde

# ==============================================================
# Core Bayesian engine: log RR -> RR & ARD
# ==============================================================

def bayes_logRR(a, n1, c, n0, mu0, sd0, use_haldane=False,
                n_draws=200000, seed=123):
    """
    Bayesian analysis for a binary endpoint using log RR as parameter.
    Prior: log RR ~ Normal(mu0, sd0^2)
    Likelihood: Normal(log RR_hat, SE^2) (Wald)
    Optionally applies Haldane-Anscombe correction if use_haldane=True.
    Returns posterior summaries and draws for RR and ARD (%).
    """
    if use_haldane:
        # Haldane-Anscombe continuity correction
        a_adj = a + 0.5
        c_adj = c + 0.5
        n1_adj = n1 + 1
        n0_adj = n0 + 1
    else:
        a_adj, c_adj, n1_adj, n0_adj = a, c, n1, n0

    # Control risk
    p_c = c_adj / n0_adj

    # Frequentist log RR and SE
    RR_hat = (a_adj / n1_adj) / (c_adj / n0_adj)
    theta_hat = math.log(RR_hat)
    se = math.sqrt(1/a_adj - 1/n1_adj + 1/c_adj - 1/n0_adj)

    # Prior and likelihood variances
    var0 = sd0**2
    varL = se**2

    # Conjugate posterior on log RR
    var_post = 1.0 / (1.0/var0 + 1.0/varL)
    sd_post = math.sqrt(var_post)
    mu_post = var_post * (theta_hat/varL + mu0/var0)

    # Draw from posterior on log RR
    rng = np.random.default_rng(seed)
    theta = rng.normal(mu_post, sd_post, n_draws)
    rr = np.exp(theta)
    ard = p_c * (rr - 1.0)  # proportion

    def summarize(x):
        x = np.array(x)
        L, med, U = np.quantile(x, [0.025, 0.5, 0.975])
        return dict(
            mean=float(x.mean()),
            median=float(med),
            L=float(L),
            U=float(U)
        )

    return dict(
        p_c=p_c,
        theta_hat=theta_hat,
        se=se,
        mu_post=mu_post,
        sd_post=sd_post,
        rr_draws=rr,
        ard_draws_pct=ard * 100.0,
        RR_summ=summarize(rr),
        ARD_summ=summarize(ard * 100.0)
    )

# ==============================================================
# Plotters
# ==============================================================

def plot_ard_half_eye(ard_draws_pct, x_min, x_max, x_step,
                      title, xlabel, mcid_line=None, color_idx=3):
    """
    Single half-eye plot (KDE) on ARD (%) axis.
    """
    ard = np.array(ard_draws_pct)
    kde = gaussian_kde(ard)
    x_grid = np.linspace(x_min, x_max, 600)
    dens = kde(x_grid)
    dens /= dens.max()
    scale = 0.8

    fig, ax = plt.subplots(figsize=(8, 3))
    color = plt.get_cmap("tab10")(color_idx)

    ax.fill_between(x_grid, 0, dens*scale, color=color, alpha=0.75)

    # no-effect line
    ax.axvline(0.0, linestyle="--", linewidth=1.1, color="black")

    # MCID line, if any
    if mcid_line is not None:
        ax.axvline(mcid_line, linestyle=":", linewidth=1.1, color="black")

    ax.set_xlim(x_min, x_max)
    xticks = np.arange(x_min, x_max + 1e-9, x_step)
    ax.set_xticks(xticks)
    ax.set_xticklabels([f"{int(v)}%" for v in xticks])

    ax.set_yticks([])
    ax.grid(False)
    ax.set_ylabel("Posterior density")
    ax.set_xlabel(xlabel)
    ax.set_title(title)

    plt.tight_layout()
    plt.show()


def plot_prior_like_post_ARD(p_c, mu0, sd0, theta_hat, se,
                             mu_post, sd_post,
                             x_min=-15, x_max=5, x_step=5,
                             mcid_line=-5,
                             n_draws=200000, seed=123,
                             title_prefix="Primary composite"):
    """
    For a given prior + likelihood + posterior (all on log RR),
    plot prior, likelihood, and posterior as half-eye densities on ARD (%) axis.
    """
    rng = np.random.default_rng(seed)

    # Draws
    theta_prior = rng.normal(mu0, sd0, n_draws)
    theta_like  = rng.normal(theta_hat, se, n_draws)
    theta_post  = rng.normal(mu_post, sd_post, n_draws)

    def theta_to_ard_pct(theta):
        rr = np.exp(theta)
        ard = p_c * (rr - 1.0)
        return ard * 100.0

    ard_prior = theta_to_ard_pct(theta_prior)
    ard_like  = theta_to_ard_pct(theta_like)
    ard_post  = theta_to_ard_pct(theta_post)

    # Helper to draw a panel
    def panel(ax, ard, title, color_idx):
        kde = gaussian_kde(ard)
        x_grid = np.linspace(x_min, x_max, 600)
        dens = kde(x_grid)
        dens /= dens.max()
        scale = 0.8
        color = plt.get_cmap("tab10")(color_idx)
        ax.fill_between(x_grid, 0, dens*scale, color=color, alpha=0.75)
        ax.axvline(0.0, linestyle="--", linewidth=1.1, color="black")
        if mcid_line is not None:
            ax.axvline(mcid_line, linestyle=":", linewidth=1.1, color="black")
        ax.set_xlim(x_min, x_max)
        xticks = np.arange(x_min, x_max + 1e-9, x_step)
        ax.set_xticks(xticks)
        ax.set_xticklabels([f"{int(v)}%" for v in xticks])
        ax.set_yticks([])
        ax.grid(False)
        ax.set_title(title, fontsize=10)

    fig, axes = plt.subplots(3, 1, figsize=(8, 7), sharex=True)

    panel(axes[0], ard_prior,
          f"{title_prefix} — PRIOR (logRR ~ N({mu0:.2f}, {sd0:.2f}²))",
          color_idx=0)
    panel(axes[1], ard_like,
          f"{title_prefix} — LIKELIHOOD (approx on logRR)",
          color_idx=1)
    panel(axes[2], ard_post,
          f"{title_prefix} — POSTERIOR",
          color_idx=3)

    axes[-1].set_xlabel("Absolute Risk Difference (Complete – Culprit-only), %")

    plt.tight_layout()
    plt.show()

# ==============================================================
# Posterior probabilities utility
# ==============================================================

def print_posterior_probs_ARD(ard_draws_pct, thresholds, label=""):
    """
    Print P(ARD <= t%) for a list of thresholds.
    """
    ard = np.array(ard_draws_pct)
    print(f"\nPosterior probabilities P(ARD ≤ t%) {label}")
    for t in thresholds:
        p = np.mean(ard <= t)
        print(f"  P(ARD ≤ {t:+.0f}%) ≈ {p:.4f}")

# ==============================================================
# 1) Composite primary endpoint under multiple priors
# ==============================================================

a_comp, n1_comp = 13, 240
c_comp, n0_comp = 32, 238
p_c_comp = c_comp / n0_comp

# MCID: -5% ARD benefit
delta_mcid = -0.05
theta_mcid = math.log(1 + delta_mcid / p_c_comp)

# Skeptical prior sd: P(ARD <= -5%) = 0.10
z_0_10 = norm.ppf(0.10)
sigma_skept = theta_mcid / z_0_10  # > 0

# Enthusiastic prior sd: centered at theta_mcid, P(harm) = 0.30
z_0_70 = norm.ppf(0.70)
sigma_enth = -theta_mcid / z_0_70   # > 0

# Meta prior (NSTEMI IPD)
a_meta, n1_meta = 68, 536
c_meta, n0_meta = 91, 532
logRR_meta = math.log((a_meta/n1_meta) / (c_meta/n0_meta))
se_logRR_meta = math.sqrt(1/a_meta - 1/n1_meta + 1/c_meta - 1/n0_meta)

priors_composite = {
    "Weak":           (0.0, 2.0),
    "Skeptical":      (0.0, sigma_skept),
    "Enthusiastic":   (theta_mcid, sigma_enth),
    "Pessimistic":    (-theta_mcid, sigma_enth),
    "Literature-based": (logRR_meta, se_logRR_meta),
}

results_composite = {}

# Use the same “likelihood” parameters for all (θ̂ and SE from weak prior run)
# We can get them from the first run.
for name, (mu0, sd0) in priors_composite.items():
    res = bayes_logRR(a_comp, n1_comp, c_comp, n0_comp, mu0, sd0)
    results_composite[name] = res
    RR = res["RR_summ"]
    ARD = res["ARD_summ"]

    print(f"\n=== Primary composite — Prior: {name} ===")
    print(f"RR:  median={RR['median']:.3f}, mean={RR['mean']:.3f}, "
          f"95%CrI=({RR['L']:.3f}, {RR['U']:.3f})")
    print(f"ARD: median={ARD['median']:.2f}%, mean={ARD['mean']:.2f}%, "
          f"95%CrI=({ARD['L']:.2f}%, {ARD['U']:.2f}%)")

    # Posterior probabilities on ARD for this prior
    thresholds_comp = [-10, -8, -6, -5, -4, -2, 0, 2]
    print_posterior_probs_ARD(res["ard_draws_pct"], thresholds_comp,
                              label=f"(Primary, {name})")

    # Prior-likelihood-posterior ARD panels
    plot_prior_like_post_ARD(
        p_c=p_c_comp,
        mu0=mu0,
        sd0=sd0,
        theta_hat=res["theta_hat"],
        se=res["se"],
        mu_post=res["mu_post"],
        sd_post=res["sd_post"],
        x_min=-15, x_max=5, x_step=5,
        mcid_line=-5,
        title_prefix=f"Primary composite — {name}"
    )

    # Posterior-only half-eye on ARD (same as before)
    plot_ard_half_eye(
        res["ard_draws_pct"],
        x_min=-15, x_max=5, x_step=5,
        title=f"Primary composite — ARD posterior (Prior: {name})",
        xlabel="Absolute Risk Difference (Complete – Culprit-only)",
        mcid_line=-5
    )

# ==============================================================
# 2) Individual endpoints under weak prior log RR ~ N(0, 2^2)
# ==============================================================

weak_mu0, weak_sd0 = 0.0, 2.0

# --- Mortality: 5/240 vs 3/238 ---
res_mort = bayes_logRR(5, 240, 3, 238, weak_mu0, weak_sd0)
print("\n=== Mortality (weak prior) ===")
print("RR:", res_mort["RR_summ"])
print("ARD:", res_mort["ARD_summ"])

thresholds_endpt = list(range(-5, 6, 1))  # -5%..+5%
print_posterior_probs_ARD(res_mort["ard_draws_pct"],
                          thresholds_endpt,
                          label="(Mortality)")

plot_ard_half_eye(
    res_mort["ard_draws_pct"],
    x_min=-4, x_max=4, x_step=1,
    title="Mortality — ARD posterior (weak prior)",
    xlabel="Absolute Risk Difference in Mortality (Complete – Culprit-only)"
)

# --- MI: 5/240 vs 12/238 ---
res_mi = bayes_logRR(5, 240, 12, 238, weak_mu0, weak_sd0)
print("\n=== Myocardial infarction (weak prior) ===")
print("RR:", res_mi["RR_summ"])
print("ARD:", res_mi["ARD_summ"])

print_posterior_probs_ARD(res_mi["ard_draws_pct"],
                          thresholds_endpt,
                          label="(MI)")

plot_ard_half_eye(
    res_mi["ard_draws_pct"],
    x_min=-8, x_max=2, x_step=2,
    title="Myocardial infarction — ARD posterior (weak prior)",
    xlabel="Absolute Risk Difference in MI (Complete – Culprit-only)"
)

# --- Repeat revascularization: 7/240 vs 27/238 ---
res_revasc = bayes_logRR(7, 240, 27, 238, weak_mu0, weak_sd0)
print("\n=== Repeat revascularization (weak prior) ===")
print("RR:", res_revasc["RR_summ"])
print("ARD:", res_revasc["ARD_summ"])

print_posterior_probs_ARD(res_revasc["ard_draws_pct"],
                          thresholds_endpt,
                          label="(Repeat revasc)")

plot_ard_half_eye(
    res_revasc["ard_draws_pct"],
    x_min=-12, x_max=2, x_step=2,
    title="Repeat revascularization — ARD posterior (weak prior)",
    xlabel="Absolute Risk Difference in Repeat Revascularization (Complete – Culprit-only)"
)

# --- Stroke: 1/240 vs 0/238, Haldane correction ---
res_stroke = bayes_logRR(1, 240, 0, 238, weak_mu0, weak_sd0, use_haldane=True)
print("\n=== Stroke (weak prior, Haldane) ===")
print("RR:", res_stroke["RR_summ"])
print("ARD:", res_stroke["ARD_summ"])

print_posterior_probs_ARD(res_stroke["ard_draws_pct"],
                          thresholds_endpt,
                          label="(Stroke)")

plot_ard_half_eye(
    res_stroke["ard_draws_pct"],
    x_min=-2, x_max=2, x_step=1,
    title="Stroke — ARD posterior (weak prior, Haldane)",
    xlabel="Absolute Risk Difference in Stroke (Complete – Culprit-only)"
)