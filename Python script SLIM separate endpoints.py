# -*- coding: utf-8 -*-
"""Untitled11.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1isdSABP9dWVCVoe-LIKWvmxl5wcfJ3iA
"""

# ============================================
# COMMON IMPORTS
# ============================================
import numpy as np
import math
import matplotlib.pyplot as plt
from scipy.stats import norm, binom

# ============================================
# 1. MORTALITY — 5/240 vs 3/238
# ARD model, flat prior on ARD, Normal approx for plot/probs
# x-axis: -4% to +4%, ticks 1%
# ============================================
print("\n" + "="*60)
print("MORTALITY")
print("="*60)

a   = 5      # deaths in complete group
n_t = 240
c   = 3      # deaths in culprit-only group
n_c = 238

p_c_hat = c / n_c
print(f"Mortality: {a}/{n_t} (complete) vs {c}/{n_c} (culprit-only)")
print(f"Baseline risk p_c = {p_c_hat:.4f} ({p_c_hat*100:.2f}%)\n")

prior_mu = 0.0
prior_sd = 1.0
print("Prior on ARD (proportion scale):")
print(f"delta ~ Normal(mean={prior_mu:.2f}, sd={prior_sd:.2f})")
print("This corresponds to mean 0% and SD 100% on ARD.\n")

grid_min  = -0.50
grid_max  =  0.50
grid_step =  0.0005

delta_grid = np.arange(grid_min, grid_max + grid_step, grid_step)
p_t_grid = p_c_hat + delta_grid
valid = (p_t_grid > 1e-9) & (p_t_grid < 1 - 1e-9)
delta_grid = delta_grid[valid]
p_t_grid   = p_t_grid[valid]
rr_grid    = p_t_grid / p_c_hat

log_like  = binom.logpmf(a, n_t, p_t_grid)
log_prior = norm.logpdf(delta_grid, loc=prior_mu, scale=prior_sd)
log_post = log_like + log_prior
log_post_max = np.max(log_post)
post_unnorm  = np.exp(log_post - log_post_max)

post_norm_const = np.sum(post_unnorm) * grid_step
post_density    = post_unnorm / post_norm_const

delta_mean   = np.sum(delta_grid * post_density) * grid_step
delta2_mean  = np.sum((delta_grid**2) * post_density) * grid_step
delta_var    = delta2_mean - delta_mean**2
delta_sd     = math.sqrt(max(delta_var, 1e-20))

cdf_vals = np.cumsum(post_density) * grid_step

def quantile_delta(q):
    return np.interp(q, cdf_vals, delta_grid)

delta_L      = quantile_delta(0.025)
delta_U      = quantile_delta(0.975)
delta_median = quantile_delta(0.50)

mean_pct   = delta_mean   * 100
L_pct      = delta_L      * 100
U_pct      = delta_U      * 100
median_pct = delta_median * 100

print("Posterior ARD for mortality (true from grid, ARD = p_t - p_c):")
print(f"Median ARD = {median_pct:.2f}%")
print(f"Mean ARD   = {mean_pct:.2f}%")
print(f"95% CrI   ≈ [{L_pct:.2f}%, {U_pct:.2f}%]\n")

def quantile_rr(q):
    return np.interp(q, cdf_vals, rr_grid)

rr_mean   = np.sum(rr_grid * post_density) * grid_step
rr_L      = quantile_rr(0.025)
rr_U      = quantile_rr(0.975)
rr_median = quantile_rr(0.50)

print("Posterior RR for mortality (from ARD-based posterior):")
print(f"Median RR = {rr_median:.3f}")
print(f"Mean RR   = {rr_mean:.3f}")
print(f"95% CrI  ≈ [{rr_L:.3f}, {rr_U:.3f}]\n")

mu_ard = delta_mean
sd_ard = delta_sd
print("Normal approximation on ARD (for plotting & probabilities):")
print(f"ARD ~ Normal(mean={mu_ard*100:.2f}%, sd={sd_ard*100:.2f}%)\n")

thresholds_pct = np.arange(-5, 6, 1)
print("Posterior probabilities P(ARD ≤ t%) for mortality (Normal approx):")
for t in thresholds_pct:
    t_prop = t / 100.0
    z = (t_prop - mu_ard) / sd_ard
    p = norm.cdf(z)
    print(f"P(ARD ≤ {t:+d}%) ≈ {p:.4f}")
print()

x_plot_min  = -4.0
x_plot_max  =  4.0
x_tick_step =  1.0

x_grid_pct  = np.linspace(x_plot_min, x_plot_max, 500)
x_grid_prop = x_grid_pct / 100.0
dens_norm = norm.pdf(x_grid_prop, loc=mu_ard, scale=sd_ard)
dens_norm /= dens_norm.max()
scale = 0.8

fig, ax = plt.subplots(figsize=(8, 3))
posterior_color = plt.get_cmap("tab10")(3)
ax.fill_between(x_grid_pct, 0, dens_norm*scale, color=posterior_color, alpha=0.75)
ax.axvline(0.0, linestyle="--", linewidth=1.1, color="black")
ax.grid(False)
ax.set_xlim(x_plot_min, x_plot_max)
xticks = np.arange(x_plot_min, x_plot_max + 1e-9, x_tick_step)
ax.set_xticks(xticks)
ax.set_xticklabels([f"{int(v)}%" for v in xticks])
ax.set_yticks([])
ax.set_ylabel("Posterior density")
ax.set_xlabel("Absolute Risk Difference in Mortality (Complete – Culprit-only)")
ax.set_title("Mortality — ARD posterior\n(Binomial likelihood + Normal(0, 100%²) prior on ARD)")
plt.tight_layout()
plt.show()


# ============================================
# 2. MI — 5/240 vs 12/238
# ARD model, flat prior on ARD, Normal approx for plot/probs
# x-axis: -8% to +2%, ticks 2%
# ============================================
print("\n" + "="*60)
print("MYOCARDIAL INFARCTION")
print("="*60)

a   = 5      # MI in complete group
n_t = 240
c   = 12     # MI in culprit-only group
n_c = 238

p_c_hat = c / n_c
print(f"Myocardial infarction: {a}/{n_t} (complete) vs {c}/{n_c} (culprit-only)")
print(f"Baseline risk p_c = {p_c_hat:.4f} ({p_c_hat*100:.2f}%)\n")

prior_mu = 0.0
prior_sd = 1.0
print("Prior on ARD (proportion scale):")
print(f"delta ~ Normal(mean={prior_mu:.2f}, sd={prior_sd:.2f})")
print("This corresponds to mean 0% and SD 100% on ARD.\n")

grid_min  = -0.50
grid_max  =  0.50
grid_step =  0.0005

delta_grid = np.arange(grid_min, grid_max + grid_step, grid_step)
p_t_grid = p_c_hat + delta_grid
valid = (p_t_grid > 1e-9) & (p_t_grid < 1 - 1e-9)
delta_grid = delta_grid[valid]
p_t_grid   = p_t_grid[valid]
rr_grid    = p_t_grid / p_c_hat

log_like  = binom.logpmf(a, n_t, p_t_grid)
log_prior = norm.logpdf(delta_grid, loc=prior_mu, scale=prior_sd)
log_post  = log_like + log_prior
log_post_max = np.max(log_post)
post_unnorm  = np.exp(log_post - log_post_max)
post_norm_const = np.sum(post_unnorm) * grid_step
post_density    = post_unnorm / post_norm_const

delta_mean   = np.sum(delta_grid * post_density) * grid_step
delta2_mean  = np.sum((delta_grid**2) * post_density) * grid_step
delta_var    = delta2_mean - delta_mean**2
delta_sd     = math.sqrt(max(delta_var, 1e-20))

cdf_vals = np.cumsum(post_density) * grid_step

def q_delta(q):
    return np.interp(q, cdf_vals, delta_grid)

delta_L      = q_delta(0.025)
delta_U      = q_delta(0.975)
delta_median = q_delta(0.50)

mean_pct   = delta_mean   * 100
L_pct      = delta_L      * 100
U_pct      = delta_U      * 100
median_pct = delta_median * 100

print("Posterior ARD for MI (true from grid, ARD = p_t - p_c):")
print(f"Median ARD = {median_pct:.2f}%")
print(f"Mean ARD   = {mean_pct:.2f}%")
print(f"95% CrI   ≈ [{L_pct:.2f}%, {U_pct:.2f}%]\n")

def q_rr(q):
    return np.interp(q, cdf_vals, rr_grid)

rr_mean   = np.sum(rr_grid * post_density) * grid_step
rr_L      = q_rr(0.025)
rr_U      = q_rr(0.975)
rr_median = q_rr(0.50)

print("Posterior RR for MI (from ARD-based posterior):")
print(f"Median RR = {rr_median:.3f}")
print(f"Mean RR   = {rr_mean:.3f}")
print(f"95% CrI  ≈ [{rr_L:.3f}, {rr_U:.3f}]\n")

mu_ard = delta_mean
sd_ard = delta_sd
print("Normal approximation on ARD (for plotting & probabilities):")
print(f"ARD ~ Normal(mean={mu_ard*100:.2f}%, sd={sd_ard*100:.2f}%)\n")

thresholds_pct = np.arange(-5, 6, 1)
print("Posterior probabilities P(ARD ≤ t%) for MI (Normal approx):")
for t in thresholds_pct:
    t_prop = t / 100.0
    z = (t_prop - mu_ard) / sd_ard
    p = norm.cdf(z)
    print(f"P(ARD ≤ {t:+d}%) ≈ {p:.4f}")
print()

x_plot_min  = -8.0
x_plot_max  =  2.0
x_tick_step =  2.0

x_grid_pct  = np.linspace(x_plot_min, x_plot_max, 500)
x_grid_prop = x_grid_pct / 100.0
dens_norm = norm.pdf(x_grid_prop, loc=mu_ard, scale=sd_ard)
dens_norm /= dens_norm.max()
scale = 0.8

fig, ax = plt.subplots(figsize=(8, 3))
posterior_color = plt.get_cmap("tab10")(3)
ax.fill_between(x_grid_pct, 0, dens_norm*scale, color=posterior_color, alpha=0.75)
ax.axvline(0.0, linestyle="--", linewidth=1.1, color="black")
ax.grid(False)
ax.set_xlim(x_plot_min, x_plot_max)
xticks = np.arange(x_plot_min, x_plot_max + 1e-9, x_tick_step)
ax.set_xticks(xticks)
ax.set_xticklabels([f"{int(v)}%" for v in xticks])
ax.set_yticks([])
ax.set_ylabel("Posterior density")
ax.set_xlabel("Absolute Risk Difference in Myocardial Infarction (Complete – Culprit-only)")
ax.set_title("Myocardial infarction — ARD posterior\n(Binomial likelihood + Normal(0, 100%²) prior on ARD)")
plt.tight_layout()
plt.show()


# ============================================
# 3. REPEAT REVASCULARIZATION — 7/240 vs 27/238
# ARD model, flat prior on ARD, Normal approx for plot/probs
# x-axis: -12% to +2%, ticks 2%
# ============================================
print("\n" + "="*60)
print("REPEAT REVASCULARIZATION")
print("="*60)

a   = 7
n_t = 240
c   = 27
n_c = 238

p_c_hat = c / n_c
print(f"Repeat revascularization: {a}/{n_t} (complete) vs {c}/{n_c} (culprit-only)")
print(f"Baseline risk p_c = {p_c_hat:.4f} ({p_c_hat*100:.2f}%)\n")

prior_mu = 0.0
prior_sd = 1.0
print("Prior on ARD: Normal(0, 1.0^2) → ~ flat\n")

grid_min  = -0.50
grid_max  =  0.50
grid_step =  0.0005

delta_grid = np.arange(grid_min, grid_max + grid_step, grid_step)
p_t_grid = p_c_hat + delta_grid
valid = (p_t_grid > 1e-9) & (p_t_grid < 1 - 1e-9)
delta_grid = delta_grid[valid]
p_t_grid   = p_t_grid[valid]
rr_grid    = p_t_grid / p_c_hat

log_like  = binom.logpmf(a, n_t, p_t_grid)
log_prior = norm.logpdf(delta_grid, loc=prior_mu, scale=prior_sd)
log_post  = log_like + log_prior
log_post_max = np.max(log_post)
post_unnorm  = np.exp(log_post - log_post_max)
post_norm_const = np.sum(post_unnorm) * grid_step
post_density    = post_unnorm / post_norm_const

delta_mean   = np.sum(delta_grid * post_density) * grid_step
delta2_mean  = np.sum((delta_grid**2) * post_density) * grid_step
delta_var    = delta2_mean - delta_mean**2
delta_sd     = math.sqrt(max(delta_var, 1e-20))

cdf_vals = np.cumsum(post_density) * grid_step

def q_delta(q):
    return np.interp(q, cdf_vals, delta_grid)

delta_L      = q_delta(0.025)
delta_U      = q_delta(0.975)
delta_median = q_delta(0.50)

mean_pct   = delta_mean   * 100
L_pct      = delta_L      * 100
U_pct      = delta_U      * 100
median_pct = delta_median * 100

print("Posterior ARD for repeat revascularization (true from grid):")
print(f"Median ARD = {median_pct:.2f}%")
print(f"Mean ARD   = {mean_pct:.2f}%")
print(f"95% CrI   ≈ [{L_pct:.2f}%, {U_pct:.2f}%]\n")

def q_rr(q):
    return np.interp(q, cdf_vals, rr_grid)

rr_mean   = np.sum(rr_grid * post_density) * grid_step
rr_L      = q_rr(0.025)
rr_U      = q_rr(0.975)
rr_median = q_rr(0.50)

print("Posterior RR for repeat revascularization:")
print(f"Median RR = {rr_median:.3f}")
print(f"Mean RR   = {rr_mean:.3f}")
print(f"95% CrI  ≈ [{rr_L:.3f}, {rr_U:.3f}]\n")

mu_ard = delta_mean
sd_ard = delta_sd
print("Normal approx:")
print(f"ARD ~ Normal({mu_ard*100:.2f}%, {sd_ard*100:.2f}%)\n")

print("P(ARD ≤ t%) from Normal approx:")
for t in range(-5, 6):
    z = (t/100 - mu_ard) / sd_ard
    print(f"P(ARD ≤ {t:+d}%) = {norm.cdf(z):.4f}")
print()

x_plot_min  = -12.0
x_plot_max  =   2.0
x_tick_step =   2.0

x_grid_pct  = np.linspace(x_plot_min, x_plot_max, 600)
x_grid_prop = x_grid_pct / 100.0
dens_norm = norm.pdf(x_grid_prop, loc=mu_ard, scale=sd_ard)
dens_norm /= dens_norm.max()
scale = 0.8

fig, ax = plt.subplots(figsize=(8, 3))
posterior_color = plt.get_cmap("tab10")(3)
ax.fill_between(x_grid_pct, 0, dens_norm*scale, color=posterior_color, alpha=0.75)
ax.axvline(0.0, linestyle="--", linewidth=1.1, color="black")
ax.set_xlim(x_plot_min, x_plot_max)
ax.set_xticks(np.arange(x_plot_min, x_plot_max+0.01, x_tick_step))
ax.set_xticklabels([f"{int(v)}%" for v in np.arange(x_plot_min, x_plot_max+0.01, x_tick_step)])
ax.set_yticks([])
ax.grid(False)
ax.set_ylabel("Posterior density")
ax.set_xlabel("Absolute Risk Difference in Repeat Revascularization (Complete – Culprit-only)")
ax.set_title("Repeat Revascularization — ARD Posterior\n(Flat Normal Prior, Binomial Likelihood)")
plt.tight_layout()
plt.show()


# ============================================
# 4. STROKE — 1/240 vs 0/238
# ARD model, flat prior on ARD, TRUE posterior curve (no Normal approx)
# x-axis: -2% to +2%, ticks 1%
# ============================================
print("\n" + "="*60)
print("STROKE")
print("="*60)

a   = 1
n_t = 240
c   = 0
n_c = 238

print(f"Stroke: {a}/{n_t} (complete) vs {c}/{n_c} (culprit-only)")

# continuity-corrected baseline risk
p_c_hat = (c + 0.5) / (n_c + 1)
print(f"Baseline risk p_c (corr) = {p_c_hat:.5f} ({p_c_hat*100:.3f}%)\n")

prior_mu = 0.0
prior_sd = 1.0
print("Prior on ARD: delta ~ Normal(0, 1.0^2)\n")

grid_min  = -0.50
grid_max  =  0.50
grid_step =  0.0005

delta_grid = np.arange(grid_min, grid_max + grid_step, grid_step)
p_t_grid   = p_c_hat + delta_grid
valid      = (p_t_grid > 1e-9) & (p_t_grid < 1 - 1e-9)
delta_grid = delta_grid[valid]
p_t_grid   = p_t_grid[valid]
rr_grid    = p_t_grid / p_c_hat

log_like  = binom.logpmf(a, n_t, p_t_grid)
log_prior = norm.logpdf(delta_grid, loc=prior_mu, scale=prior_sd)
log_post  = log_like + log_prior
log_post_max = np.max(log_post)
post_unnorm  = np.exp(log_post - log_post_max)
post_norm_const = np.sum(post_unnorm) * grid_step
post_density    = post_unnorm / post_norm_const

delta_mean   = np.sum(delta_grid * post_density) * grid_step
delta2_mean  = np.sum((delta_grid**2) * post_density) * grid_step
delta_var    = delta2_mean - delta_mean**2
delta_sd     = math.sqrt(max(delta_var, 1e-20))

cdf_vals = np.cumsum(post_density) * grid_step

def q_delta(q):
    return np.interp(q, cdf_vals, delta_grid)

delta_L      = q_delta(0.025)
delta_U      = q_delta(0.975)
delta_median = q_delta(0.50)

mean_pct   = delta_mean   * 100
L_pct      = delta_L      * 100
U_pct      = delta_U      * 100
median_pct = delta_median * 100

print("Posterior ARD for stroke (true grid posterior):")
print(f"Median ARD = {median_pct:.3f}%")
print(f"Mean ARD   = {mean_pct:.3f}%")
print(f"95% CrI   ≈ [{L_pct:.3f}%, {U_pct:.3f}%]\n")

def q_rr(q):
    return np.interp(q, cdf_vals, rr_grid)

rr_mean   = np.sum(rr_grid * post_density) * grid_step
rr_L      = q_rr(0.025)
rr_U      = q_rr(0.975)
rr_median = q_rr(0.50)

print("Posterior RR for stroke (from grid posterior):")
print(f"Median RR = {rr_median:.3f}")
print(f"Mean RR   = {rr_mean:.3f}")
print(f"95% CrI  ≈ [{rr_L:.3f}, {rr_U:.3f}]\n")

print("Posterior probabilities P(ARD ≤ t%) for stroke (grid-based):")
for t in range(-5, 6):
    t_prop = t / 100.0
    p = np.interp(t_prop, delta_grid, cdf_vals)
    print(f"P(ARD ≤ {t:+d}%) ≈ {p:.4f}")
print()

x_min_pct  = -2.0
x_max_pct  =  2.0
mask       = (delta_grid*100 >= x_min_pct) & (delta_grid*100 <= x_max_pct)
x_plot_pct = delta_grid[mask] * 100
dens_plot  = post_density[mask]
dens_plot /= dens_plot.max()
scale = 0.8

fig, ax = plt.subplots(figsize=(8, 3))
posterior_color = plt.get_cmap("tab10")(3)
ax.fill_between(x_plot_pct, 0, dens_plot*scale,
                color=posterior_color, alpha=0.75)
ax.axvline(0.0, linestyle="--", linewidth=1.1, color="black")
ax.set_xlim(x_min_pct, x_max_pct)
ax.set_xticks(np.arange(x_min_pct, x_max_pct+0.01, 1.0))
ax.set_xticklabels([f"{int(v)}%" for v in np.arange(x_min_pct, x_max_pct+0.01, 1.0)])
ax.set_yticks([])
ax.grid(False)
ax.set_ylabel("Posterior density")
ax.set_xlabel("Absolute Risk Difference in Stroke (Complete – Culprit-only)")
ax.set_title("Stroke — ARD posterior\n(Binomial likelihood + flat Normal prior on ARD)")
plt.tight_layout()
plt.show()